# sleigh include file for Skeleton language instructions

define token instra (16)
    op12     = (4,15)
    op8      = (8,15)
    op5      = (11,15)
    op4      = (12,15)

    i8       = (4,11)
    o8       = (4,11)
    u4       = (4,7)
    m4       = (4,7)
    i4       = (4,7)
    rj       = (4,7)

    rel11    = (0,10)
    u8       = (0,7)
    rel8     = (0,7)
    dir      = (0,7)
    rlist    = (0,7)

    ri       = (0,3)
    rs       = (0,3)
;

attach variables [ ri rj ] [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 AC FP SP ];
attach variables rs [ TBR RP SSP USP MDH MDL ];

macro resultFlags(result) {
  $(N_flag) = (result s< 0);
  $(Z_flag) = (result == 0);
}

macro addFlags(result, val1, val2) {
  $(N_flag) = (result s< 0);
  $(Z_flag) = (result == 0);
  $(V_flag) = ((val1 s>= 0) & (val2 s>= 0) & (result s< 0)) | ((val1 s< 0) & (val2 s< 0) & (result s>= 0));
  $(C_flag) = scarry(val1, val2);
}

macro subFlags(result, val1, val2) {
  $(N_flag) = (result s< 0);
  $(Z_flag) = (result == 0);
  $(V_flag) = ((val1 s< 0) & (val2 s>= 0) & (result s< 0)) | ((val1 s>= 0) & (val2 s< 0) & (result s>= 0));
  $(C_flag) = sborrow(val1, val2);
}


:ADD rj, ri is op8=0xa6 & rj & ri {
    tmpi:4 = ri;
    ri = ri + rj;
    addFlags(ri, tmpi, rj);
}

:ADD #^i4, ri is op8=0xa4 & i4 & ri {
    tmpi:4 = ri;
    ri = ri + zext(i4);
    addFlags(ri, tmpi, zext(i4));
}

:ADD2 #^i4, ri is op8=0xa5 & i4 & ri {
    tmpi:4 = ri;
    ri = ri + sext(i4);
    addFlags(ri, tmpi, sext(i4));
}

:ADDC rj, ri is op8=0xa7 & rj & ri {
    tempi:4 = ri;
    ri = ri + rj + zext($(C_flag));
    addFlags(ri, tmpi, (rj + zext($(C_flag))));
}

:ADDN rj, ri is op8=0xa2 & rj & ri {
    ri = ri + rj;
}

:ADDN #^i4, ri is op8=0xa0 & i4 & ri {
    ri = ri + zext(i4);
}

:ADDN2 #^i4, ri is op8=0xa1 & i4 & ri {
    ri = ri + sext(i4);
}

:SUB rj, ri is op8=0xac & rj & ri {
    tmpi:4 = ri;
    ri = ri - rj;
    subFlags(ri, tmpi, rj);
}

:SUBC rj, ri is op8=0xad & rj & ri {
    tmpi:4 = ri;
    ri = ri - rj - zext($(C_flag));
    subFlags(ri, tmpi, (rj - zext($(C_flag))));
}

:SUBN rj, ri is op8=0xae & rj & ri {
    ri = ri - rj;
}

:CMP rj, ri is op8=0xaa & rj & ri {
    res:4 = ri - rj;
    subFlags(res, ri, rj);
}

:CMP rj, ri is op8=0xa8 & i4 & ri {
    res:4 = ri - zext(i4);
    subFlags(res, ri, zext(i4));
}

:CMP2 rj, ri is op8=0xa9 & i4 & ri {
    res:4 = ri - sext(i4);
    subFlags(res, ri, sext(i4));
}

:AND rj, ri is op8=0x82 & rj & ri {
    ri = ri & rj;
    resultFlags(ri);
}

:AND rj, @^ri is op8=0x84 & rj & ri {
    *ri = *ri & rj;
    resultFlags(*ri);
}